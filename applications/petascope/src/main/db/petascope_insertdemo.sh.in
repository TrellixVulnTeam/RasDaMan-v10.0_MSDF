#!/bin/bash
#
# This file is part of rasdaman community.
#
# Rasdaman community is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Rasdaman community is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 Peter Baumann /
# rasdaman GmbH.
#
# For more information please see <http://www.rasdaman.org>
# or contact Peter Baumann via <baumann@rasdaman.com>.
#
# ------------------------------------------------------------------------------
#
# SYNOPSIS
# ./petascope_insertdemo.sh
#
# Description
#  Command-line utility for updating the petascope database. The updating is
#  done by importing all appropriate updateX.sql files to postgres. The script
#  determines automatically which updates need to be imported. There are two
#  cases:
#   1. no petascope database is present, in which case the updates start from 0.
#   2. a ps_dbupdates table is present, in this case the updates start from the
#      number saved in the update column.
#
#  Database connection details are read from etc/petascope.properties
#
# PRECONDITIONS
#  1) PostgreSQL server must be running
#  2) etc/petascope.properties should be present, and the metadata_user should
#     have appropriate write rights in postgres.
#  3) share/rasdaman/petascope should contain the SQL update scripts

PROG=`basename $0`

CODE_OK=0
CODE_FAIL=255

# petascope settings file
SETTINGS=@sysconfdir@/petascope.properties

# petascope updateN.sql scripts
SCRIPT_DIR=@pkgdatadir@/petascope


# ------------------------------------------------------------------------------
# functions
# ------------------------------------------------------------------------------

#
# logging
#
log() {
  echo "$PROG: $*"
}
logn() {
  echo -n "$PROG: $*"
}
error() {
  echo "$PROG: $*" >&2
  echo "$PROG: exiting." >&2
  exit $CODE_FAIL
}
feedback() {
  if [ $? -ne 0 ]; then
    echo failed.
    echo "$PROG: exiting." >&2
    exit $CODE_FAIL
  else
    echo ok.
  fi
}

#
# checks
#
check_postgres() {
  which psql > /dev/null || error "PostgreSQL missing, please add psql to the PATH."
  pgrep postgres > /dev/null
  if [ $? -ne 0 ]; then
    pgrep postmaster > /dev/null || error "The PostgreSQL service is not started."
  fi
  psql -U $PS_USER -p $PS_PORT --list 2>&1 | egrep "\b$PS_DB\b" > /dev/null
  if [ $? -ne 0 ]; then
    error "no petascope database found, please run update_petascopedb.sh first."
  fi
}
check_rasdaman() {
  which rasql > /dev/null || error "rasdaman not installed, please add rasql to the PATH."
  pgrep rasmgr > /dev/null || error "rasdaman not started, please start with start_rasdaman.sh"

  # set rascontrol login
  if [ -z "$RASLOGIN" ]; then
    export RASLOGIN=rasadmin:d293a15562d3e70b6fdc5ee452eaed40
  fi
  $RASCONTROL -x 'list srv -all' > /dev/null || error "no rasdaman servers started."
}
check_paths() {
  if [ ! -f "$SETTINGS" ]; then
	  error "petascope settings not found: $SETTINGS"
  fi
  if [ ! -d "$SCRIPT_DIR" ]; then
    error "SQL update script directory not found: $SCRIPT_DIR"
  fi
}

#
# import 2D geo-referenced data
#
function import_mst()
{
  local TESTDATA_PATH="$1"
  if [ ! -f "$TESTDATA_PATH/mean_summer_airtemp.tif" ]; then
    error "testdata file $TESTDATA_PATH/mean_summer_airtemp.tif not found"
  fi

  c='mean_summer_airtemp'
  X=885
  Y=710

  c_colltype='GreySet'
  c_basetype='char'
  c_covtype='RectifiedGridCoverage'

  c_crs='http://kahlua.eecs.jacobs-university.de:8080/def/crs/EPSG/0/4326'

  min_x_geo_coord="111.975"
  max_y_geo_coord="-8.975"
  x_res='0.05'
  y_res='-0.05'

  c_band='value'

  #
  # START
  #

  $RASQL -q "create collection $c $c_colltype" > /dev/null || exit $RC_ERROR
  $RASQL -q "insert into $c values ($c_basetype) inv_tiff(\$1)" -f "$TESTDATA_PATH"/mean_summer_airtemp.tif > /dev/null || exit $RC_ERROR

  # general coverage information (name, type, ...)
  $PSQL -c "INSERT INTO ps9_coverage (name, gml_type_id, native_format_id) \
            VALUES ('$c', (SELECT id FROM ps9_gml_subtype WHERE subtype='$c_covtype'), \
            (SELECT id FROM ps9_mime_type WHERE mime_type='application/x-octet-stream'));" > /dev/null || exit $RC_ERROR

  # get the coverage id
  c_id=$($PSQL -c  "SELECT id FROM ps9_coverage WHERE name = '$c' " | head -3 | tail -1) > /dev/null || exit $RC_ERROR

  # get the collection OID (note: take the first OID)
  c_oid=$($RASQL -q "select oid(m) from $c as m" --out string | grep ' 1:' | awk -F ':' '{print $2}' | tr -d ' \n') > /dev/null || exit $RC_ERROR

  # range set: link the coverage to the rasdaman collection
  $PSQL -c "INSERT INTO ps9_rasdaman_collection (name, oid) VALUES ('$c', $c_oid);" > /dev/null
  $PSQL -c "INSERT INTO ps9_range_set (coverage_id, storage_id) VALUES (\
              (SELECT id FROM ps9_coverage WHERE name='$c'), \
              (SELECT id FROM ps9_rasdaman_collection WHERE name='$c'));" > /dev/null || exit $RC_ERROR

  # describe the datatype of the coverage cell values (range type)
  # note: assign dimensionless quantity
  $PSQL -c "INSERT INTO ps9_range_type_component (coverage_id, name, component_order, data_type_id, field_id) VALUES (\
              $c_id, '$c_band', 0, \
              (SELECT id FROM ps9_range_data_type WHERE name='$c_basetype'), \
              (SELECT id FROM ps9_quantity WHERE description='$c_basetype' LIMIT 1));" > /dev/null || exit $RC_ERROR

  # describe the geo (`index` in this case..) domain
  $PSQL -c "INSERT INTO ps9_crs (uri) SELECT '$c_crs' WHERE NOT EXISTS (SELECT 1 FROM ps9_crs WHERE uri='$c_crs');" > /dev/null
  $PSQL -c "INSERT INTO ps9_domain_set (coverage_id, native_crs_ids) \
            VALUES ($c_id, ARRAY[(SELECT id FROM ps9_crs WHERE uri='$c_crs')]);" > /dev/null || exit $RC_ERROR
  $PSQL -c "INSERT INTO ps9_gridded_domain_set (coverage_id, grid_origin) \
            VALUES ($c_id, '{$max_y_geo_coord, $min_x_geo_coord}');" > /dev/null || exit $RC_ERROR
  # grid axes:
  $PSQL -c "INSERT INTO ps9_grid_axis (gridded_coverage_id, rasdaman_order) VALUES ($c_id, 0);" > /dev/null || exit $RC_ERROR
  $PSQL -c "INSERT INTO ps9_grid_axis (gridded_coverage_id, rasdaman_order) VALUES ($c_id, 1);" > /dev/null || exit $RC_ERROR

  # offset vectors
  $PSQL -c "INSERT INTO ps9_rectilinear_axis (grid_axis_id, offset_vector) VALUES (\
              (SELECT id FROM ps9_grid_axis WHERE gridded_coverage_id=$c_id AND rasdaman_order=0), \
              '{0, $x_res}');" > /dev/null || exit $RC_ERROR
  $PSQL -c "INSERT INTO ps9_rectilinear_axis (grid_axis_id, offset_vector) VALUES (\
              (SELECT id FROM ps9_grid_axis WHERE gridded_coverage_id=$c_id AND rasdaman_order=1), \
              '{$y_res, 0}');" > /dev/null || exit $RC_ERROR
}

# ------------------------------------------------------------------------------
# work
# ------------------------------------------------------------------------------

check_paths

#
# postgres connection details
#
PS_USER=`grep metadata_user "$SETTINGS" | awk -F "=" '{print $2}'`
PS_USER="${PS_USER#"${PS_USER%%[![:space:]]*}"}"
PS_PASS=`grep metadata_pass "$SETTINGS" | awk -F "=" '{print $2}'`
PS_PASS="${PS_PASS#"${PS_PASS%%[![:space:]]*}"}"
PS_DB=`grep metadata_url "$SETTINGS" | awk -F "/" '{print $4}' | tr -d '\n'`
PS_PORT=`grep metadata_url "$SETTINGS" | awk -F ":|/" '{print $6}' | tr -d '\n'`

# add user/pass to the .pgpass file
PGPASS_LINE="$HOSTNAME:*:*:$PS_USER:$PS_PASS"
PGPASS_FILE="$HOME/.pgpass"
if [ ! -f $PGPASS_FILE ]; then
  echo "$PGPASS_LINE" > $PGPASS_FILE
  chmod 600 $PGPASS_FILE
else
  grep "$PS_USER" $PGPASS_FILE > /dev/null
  if [ $? -ne 0 ]; then
    echo "$PGPASS_LINE" >> $PGPASS_FILE
  fi
fi

#
# postgress commands
#
PSQL="psql -U $PS_USER -d $PS_DB -p $PS_PORT"

# print some info
log "postgres settings read from $SETTINGS"
log "  user: $PS_USER"
log "  port: $PS_PORT"
log "  db: $PS_DB"

check_postgres

#
# rasdaman connection details
#
RAS_USER=`grep rasdaman_admin_user "$SETTINGS" | awk -F "=" '{print $2}' | tr -d '\n'`
RAS_PASS=`grep rasdaman_admin_pass "$SETTINGS" | awk -F "=" '{print $2}' | tr -d '\n'`
RAS_DB=`grep rasdaman_database "$SETTINGS" | awk -F "=" '{print $2}' | tr -d '\n'`
RAS_SERVER=`grep rasdaman_url "$SETTINGS" | awk -F ":|/" '{print $4}' | tr -d '\n'`
RAS_PORT=`grep rasdaman_url "$SETTINGS" | awk -F ":|/" '{print $5}' | tr -d '\n'`

#
# rasdaman commands
#
RASQL="@bindir@/rasql --user $RAS_USER --passwd $RAS_PASS -d $RAS_DB -s $RAS_SERVER -p $RAS_PORT"
RASCONTROL="@bindir@/rascontrol"

# print some info
log "rasdaman settings"
log "  user: $RAS_USER"
log "  host: $RAS_SERVER"
log "  port: $RAS_PORT"
log "  db: $RAS_DB"

check_rasdaman

#
# insert sample data to rasdaman
#
import_mst "$SCRIPT_DIR"
