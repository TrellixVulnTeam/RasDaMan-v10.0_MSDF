/*
	WCPS JLex specification - author: Mattia Parigiani

	This is the JLex specification file for the WCPS abstract grammar. The JLex executable produces a Scanner.java source file which encapsulated
	all symbol and token definition and which is needed by the Java CUP parser
	
	This file specifies all possible tokens / symbols that may appear in a WCPS request
	
	New symbols may be added following the same syntax standard
	
*/





/*
	Required declarations for source generator.
	Make sure you know what you are doing if you wish to modify these declarations
*/


import java_cup.runtime.*;
import java.io.*;
%%

%notunix
%implements java_cup.runtime.Scanner
%type Symbol
%function next_token
%class WCPSScanner
%eofval{ return null;
%eofval}

/*
	WCPS data types specification
*/

IDENTIFIER = [a-zA-Z][a-zA-Z0-9]*
NUMBER = [0-9]+
FLOATNUMBER = [-+]?[0-9]*\.?[0-9]+


/*
	WCPS Tokens specification

*/


%%
"+" { return new Symbol(WCPSSymbol.PLUS, yytext()); }
"*" { return new Symbol(WCPSSymbol.MULTI, yytext()); }
"/" { return new Symbol(WCPSSymbol.DIVIDE, yytext()); }
"-" { return new Symbol(WCPSSymbol.MINUS, yytext()); }
"(" { return new Symbol(WCPSSymbol.LPAREN, yytext()); }
")" { return new Symbol(WCPSSymbol.RPAREN, yytext()); }
"{" { return new Symbol(WCPSSymbol.LBRACE, yytext()); }
"}" { return new Symbol(WCPSSymbol.RBRACE, yytext()); }
"struct" { return new Symbol(WCPSSymbol.STRUCT, yytext()); }
"sin" { return new Symbol(WCPSSymbol.SIN, yytext()); }
"cos" { return new Symbol(WCPSSymbol.COS, yytext()); }
"tan" { return new Symbol(WCPSSymbol.TAN, yytext()); }
"sinh" { return new Symbol(WCPSSymbol.SINH, yytext()); }
"cosh" { return new Symbol(WCPSSymbol.COSH, yytext()); }
"tanh" { return new Symbol(WCPSSymbol.TANH, yytext()); }
"arcsin" { return new Symbol(WCPSSymbol.ARCSIN, yytext()); }
"arccos" { return new Symbol(WCPSSymbol.ARCCOS, yytext()); }
"arctan" { return new Symbol(WCPSSymbol.ARCTAN, yytext()); }
"exp" { return new Symbol(WCPSSymbol.EXP, yytext()); }
"log" { return new Symbol(WCPSSymbol.LOG, yytext()); }
"ln" { return new Symbol(WCPSSymbol.LN, yytext()); }
"abs" { return new Symbol(WCPSSymbol.ABS, yytext()); }
"sqrt" { return new Symbol(WCPSSymbol.SQRT, yytext()); }
":" { return new Symbol(WCPSSymbol.COLON, yytext()); }
"." { return new Symbol(WCPSSymbol.DOT, yytext()); }
"return" { return new Symbol(WCPSSymbol.RETURN, yytext()) ;}
"for" { return new Symbol(WCPSSymbol.FOR, yytext()) ;}
"in" { return new Symbol(WCPSSymbol.IN, yytext()) ; }
"," { return new Symbol(WCPSSymbol.COMMA, yytext()); }
"encode" { return new Symbol(WCPSSymbol.ENCODE, yytext()) ; }
"condense" { return new Symbol(WCPSSymbol.CONDENSE, yytext()) ; }
"over" { return new Symbol(WCPSSymbol.OVER, yytext()) ; }
"using" { return new Symbol(WCPSSymbol.USING, yytext()) ; }
"max" { return new Symbol(WCPSSymbol.MAX, yytext()) ; }
"min" { return new Symbol(WCPSSymbol.MIN, yytext()) ; }
"and" { return new Symbol(WCPSSymbol.AND, yytext()) ; }
"or" { return new Symbol(WCPSSymbol.OR, yytext()) ; }
"setNull" { return new Symbol(WCPSSymbol.SETNULL, yytext()) ; }
"setInterpolation" { return new Symbol(WCPSSymbol.SETINTERPOLATION, yytext()) ; }
"setCrs" { return new Symbol(WCPSSymbol.SETCRS, yytext()) ; }
"setAxis" { return new Symbol(WCPSSymbol.SETAXIS, yytext()) ; }
"nearest neighbor" { return new Symbol(WCPSSymbol.NEAREST, yytext()) ; }
"bilinear" { return new Symbol(WCPSSymbol.BILINEAR, yytext()) ; }
"barycentric" { return new Symbol(WCPSSymbol.BARYCENTRIC, yytext()) ; }
"bicubic" { return new Symbol(WCPSSymbol.BICUBIC, yytext()) ; }
"lost-area" { return new Symbol(WCPSSymbol.LOSTAREA, yytext()) ; }
"yDomain" { return new Symbol(WCPSSymbol.YDOMAIN, yytext()) ; }
"xDomain" { return new Symbol(WCPSSymbol.XDOMAIN, yytext()) ; }
"sDomain" { return new Symbol(WCPSSymbol.SDOMAIN, yytext()) ; }
"tDomain" { return new Symbol(WCPSSymbol.TDOMAIN, yytext()) ; }
"cTransform" { return new Symbol(WCPSSymbol.CTRANSFORM, yytext()) ; }
"scale" { return new Symbol(WCPSSymbol.SCALE, yytext()) ; }
"res" { return new Symbol(WCPSSymbol.RES, yytext()) ; }
"dim" { return new Symbol(WCPSSymbol.DIM, yytext()) ; }
"cellType" { return new Symbol(WCPSSymbol.CELLTYPE, yytext()) ; }
"crs" { return new Symbol(WCPSSymbol.CRS, yytext()) ; }
"count" { return new Symbol(WCPSSymbol.COUNT, yytext()) ; }
"all" { return new Symbol(WCPSSymbol.ALL, yytext()) ; }
"add" { return new Symbol(WCPSSymbol.ADD, yytext()) ; }
"some" { return new Symbol(WCPSSymbol.SOME, yytext()) ; }
"avg" { return new Symbol(WCPSSymbol.AVG, yytext()) ; }
"bool" { return new Symbol(WCPSSymbol.BOOL, yytext()) ; }
"char" { return new Symbol(WCPSSymbol.CHAR, yytext()) ; }
"unsigned char" { return new Symbol(WCPSSymbol.UNSIGNEDCHAR, yytext()) ; }
"unsigned short" { return new Symbol(WCPSSymbol.UNSIGNEDSHORT, yytext()) ; }
"short" { return new Symbol(WCPSSymbol.SHORT, yytext()) ; }
"long" { return new Symbol(WCPSSymbol.LONG, yytext()) ; }
"unsigned long" { return new Symbol(WCPSSymbol.UNSIGNEDLONG, yytext()) ; }
"float" { return new Symbol(WCPSSymbol.FLOAT, yytext()) ; }
"double" { return new Symbol(WCPSSymbol.DOUBLE, yytext()) ; }
"not" { return new Symbol(WCPSSymbol.NOT, yytext()) ; }
"bit" { return new Symbol(WCPSSymbol.BIT, yytext()) ; }
"xor" { return new Symbol(WCPSSymbol.XOR, yytext()) ; }
"=" { return new Symbol(WCPSSymbol.EQUALS, yytext()) ; }
"!=" { return new Symbol(WCPSSymbol.NOTEQUALS, yytext()) ; }
"overlay" { return new Symbol(WCPSSymbol.OVERLAY, yytext()) ; }
">" { return new Symbol(WCPSSymbol.GT, yytext()) ; }
"<" { return new Symbol(WCPSSymbol.LT, yytext()) ; }
"<=" { return new Symbol(WCPSSymbol.LTE, yytext()) ; }
">=" { return new Symbol(WCPSSymbol.GTE, yytext()) ; }
"[" { return new Symbol(WCPSSymbol.LBRACKET, yytext()) ; }
"]" { return new Symbol(WCPSSymbol.RBRACKET, yytext()) ; }
"trim" { return new Symbol(WCPSSymbol.TRIM, yytext()) ; }
"sect" { return new Symbol(WCPSSymbol.SECT, yytext()) ; }
"true" { return new Symbol(WCPSSymbol.TRUE, yytext()) ; }
"false" { return new Symbol(WCPSSymbol.FALSE, yytext()) ; }
{IDENTIFIER} {return new Symbol(WCPSSymbol.ID, yytext()); }
{NUMBER} { return new Symbol(WCPSSymbol.NUMBER, new Integer(yytext()));}  
{FLOATNUMBER} { return new Symbol(WCPSSymbol.FLOATNUMBER, new Float(yytext()));}  
\n {System.out.println("newline" + yytext()); }
. {System.out.println("illegal input" + yytext()); }
