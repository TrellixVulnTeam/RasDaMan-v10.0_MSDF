/*
* This file is part of rasdaman community.
*
* Rasdaman community is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Rasdaman community is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 Peter Baumann /
rasdaman GmbH.
*
* For more information please see <http://www.rasdaman.org>
* or contact Peter Baumann via <baumann@rasdaman.com>.
*/
/*************************************************************
 *
 *
 * PURPOSE: 
 * Example program for rasql query invocation from C++, showing a
 * typical mapping scenario.
 *
 *
 * BUGS:
 * - needs this link cmd line
 *   query2: query2.o
 *      $(CXX) $(LDFLAGS) -o $@ $^  \
 *      -L$(RMANHOME)/lib -lrasodmg -lclientcomm -lcompression -lconversion -lraslib -lnetwork -ljpeg -lpng -ltiff -lmfhdf -ldf -lcrypt o -lclientcomm -lm -lz
 *
 ************************************************************/

#include <iostream>

// Linux needs this for template instantiation
#ifdef EARLY_TEMPLATE
#define __EXECUTABLE__
#ifdef __GNUG__
#include "raslib/template_inst.hh"
#endif
#endif

// this file is generated by the rasdl processor
#include "basictypes.hh"

// connectivity constants
char *host = "localhost";
int  port = 7001;
char *db = "RASBASE";
char *userName = "rasguest";
char *userPass = "rasguest";

// demo program settings
// - collection ("map") name
char *collection = "rgb";
// - coordinates of map bbox to be retrieved
unsigned int xImageLo = 100;
unsigned int xImageHi = 200;
unsigned int yImageLo = 100;
unsigned int yImageHi = 200;
// - target window size
unsigned int xSize = 10;
unsigned int ySize = 10;

// global connection objects
r_Database database;
r_Transaction transaction;

// sample image accessing function, typical for mapping applications
//	input: collection ("map") name, source image coordinates, target window size
//	output: ptr to image array
// precondition: we're accessing an RGB image, so that we can select the "green" channel of it
// note: the most important parts contain markups at the beginning of the line
unsigned char *readImage( const char *collection, int xImageLo, int xImageHi, int yImageLo, int yImageHi, int xSize, int ySize ) throw (r_Error)
{
	r_Set< r_Ref< r_GMarray > >      imageSet;	// result set
	r_Ref< r_GMarray >               image;
	r_Iterator< r_Ref< r_GMarray > > iter;

	// function result
	unsigned char *result = NULL;

	try
	{
		cout << "creating query..." << flush;
		// parameters:
		//	$1	map bbox coordinate, lower x
		//	$2	map bbox coordinate, upper x
		//	$3	map bbox coordinate, lower y
		//	$4	map bbox coordinate, upper y
		//	$5	result window x size
		//	$6	result window y size
		//	$7	collection (i.e., map) name
/* 1 */		r_OQL_Query query("select scale(img.green[$1:$2,$3:$4],[1:$5,1:$6]) from $7 as img");

		cout << "substituting parameters ..." << flush;
/* 2 */		query << xImageLo << xImageHi << yImageLo << yImageHi << xSize << ySize << collection;
		cout << "[query: " << query.get_query() << "]...";

		cout << "executing query..." << flush;
/* 3 */		r_oql_execute( query, imageSet );

		// now we assume a result has come back
		iter = imageSet.create_iterator();
		iter.reset();
/* 4 */		result = (unsigned char*) (*iter)->get_array();

	}
	catch(r_Error& e)
	{
		cout << "Error: query failed: " << e.what() << flush;
		throw; 
	}

	return result;
}

// simple wrapper, handling db connectivity and demo output
int main()
{   
	try
	{
		database.set_servername( host, port );
		database.set_useridentification( userName, userPass );
	
		cout << "Opening database " << db << " on " << host << "..." << flush;
		database.open( db );
	
		cout << "starting read-only transaction..." << flush;
		transaction.begin( r_Transaction::read_only );

		// the real workhorse: fetch image data
		unsigned char *imgPtr = readImage( collection, xImageLo, xImageHi, yImageLo, yImageHi, xSize, ySize );

		cout << "result image:" << endl << hex;
		for (int i = 0; i < xSize; i++)
		{
			for (int j = 0; j < ySize; j++)
			{
				register unsigned char c = *imgPtr;
				cout << " " << setw(2) << (unsigned short) (c & 0xFF);
				imgPtr++;
			}
			cout << endl;
		}
		cout << dec;
	}
	catch(r_Error& e)
	{
		cout << "Error: cannot access database: " << e.what() << endl << flush;
	}


	// ignore any (previous) errors for connection close
	try
	{
		cout << "aborting transaction..." << flush;
		transaction.abort();
	
		cout << "closing database..." << flush;
		database.close();

		cout << "done." << endl;
	}
	catch(r_Error &e)
	{
		cout << "Error closing connection: " << e.what() << endl << flush;
	}

	return 0;
}

/* 
 * end of query2.cc
 */
