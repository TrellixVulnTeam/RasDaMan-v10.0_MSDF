#include <stdio.h>
#include "raslib/error.hh"
#include "raslib/rminit.hh"
/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "rpcif.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

ServerVersionRes *
rpcgetserverversion_1(int *argp, CLIENT *clnt)
{
	static ServerVersionRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETSERVERVERSION,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_ServerVersionRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcshutdown_1(int *argp, CLIENT *clnt)
{
	static u_short clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, RPCSHUTDOWN,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ServerStatRes *
rpcserverstat_1(int *argp, CLIENT *clnt)
{
	static ServerStatRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCSERVERSTAT,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_ServerStatRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpckilltableentry_1(u_long *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCKILLTABLEENTRY,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcalive_1(u_long *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCALIVE,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

OpenDBRes *
rpcopendb_1(OpenDBParams *argp, CLIENT *clnt)
{
	static OpenDBRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCOPENDB,
		(xdrproc_t) xdr_OpenDBParams, (caddr_t) argp,
		(xdrproc_t) xdr_OpenDBRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcclosedb_1(u_long *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCCLOSEDB,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpccreatedb_1(char **argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCCREATEDB,
		(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcdestroydb_1(char **argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCDESTROYDB,
		(xdrproc_t) xdr_wrapstring, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcbeginta_1(BeginTAParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCBEGINTA,
		(xdrproc_t) xdr_BeginTAParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpccommitta_1(u_long *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCCOMMITTA,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcabortta_1(u_long *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCABORTTA,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

ExecuteQueryRes *
rpcexecutequery_1(ExecuteQueryParams *argp, CLIENT *clnt)
{
	static ExecuteQueryRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCEXECUTEQUERY,
		(xdrproc_t) xdr_ExecuteQueryParams, (caddr_t) argp,
		(xdrproc_t) xdr_ExecuteQueryRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetMDDRes *
rpcgetnextmdd_1(u_long *argp, CLIENT *clnt)
{
	static GetMDDRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETNEXTMDD,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_GetMDDRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetMDDRes *
rpcgetmddbyoid_1(OIdSpecParams *argp, CLIENT *clnt)
{
	static GetMDDRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETMDDBYOID,
		(xdrproc_t) xdr_OIdSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_GetMDDRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetTileRes *
rpcgetnexttile_1(u_long *argp, CLIENT *clnt)
{
	static GetTileRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETNEXTTILE,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_GetTileRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcendtransfer_1(u_long *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCENDTRANSFER,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcinitexecuteupdate_1(u_long *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCINITEXECUTEUPDATE,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

ExecuteUpdateRes *
rpcexecuteupdate_1(ExecuteQueryParams *argp, CLIENT *clnt)
{
	static ExecuteUpdateRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCEXECUTEUPDATE,
		(xdrproc_t) xdr_ExecuteQueryParams, (caddr_t) argp,
		(xdrproc_t) xdr_ExecuteUpdateRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcstartinserttransmdd_1(InsertTransMDDParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCSTARTINSERTTRANSMDD,
		(xdrproc_t) xdr_InsertTransMDDParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcstartinsertpersmdd_1(InsertPersMDDParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCSTARTINSERTPERSMDD,
		(xdrproc_t) xdr_InsertPersMDDParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcinserttile_1(InsertTileParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCINSERTTILE,
		(xdrproc_t) xdr_InsertTileParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcendinsertmdd_1(EndInsertMDDParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCENDINSERTMDD,
		(xdrproc_t) xdr_EndInsertMDDParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcinsertmdd_1(InsertMDDParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCINSERTMDD,
		(xdrproc_t) xdr_InsertMDDParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetCollRes *
rpcgetcollbyname_1(NameSpecParams *argp, CLIENT *clnt)
{
	static GetCollRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETCOLLBYNAME,
		(xdrproc_t) xdr_NameSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_GetCollRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetCollRes *
rpcgetcollbyoid_1(OIdSpecParams *argp, CLIENT *clnt)
{
	static GetCollRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETCOLLBYOID,
		(xdrproc_t) xdr_OIdSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_GetCollRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetCollOIdsRes *
rpcgetcolloidsbyname_1(NameSpecParams *argp, CLIENT *clnt)
{
	static GetCollOIdsRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETCOLLOIDSBYNAME,
		(xdrproc_t) xdr_NameSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_GetCollOIdsRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetCollOIdsRes *
rpcgetcolloidsbyoid_1(OIdSpecParams *argp, CLIENT *clnt)
{
	static GetCollOIdsRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETCOLLOIDSBYOID,
		(xdrproc_t) xdr_OIdSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_GetCollOIdsRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcinsertcoll_1(InsertCollParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCINSERTCOLL,
		(xdrproc_t) xdr_InsertCollParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcdeletecollbyname_1(NameSpecParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCDELETECOLLBYNAME,
		(xdrproc_t) xdr_NameSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcdeleteobjbyoid_1(OIdSpecParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCDELETEOBJBYOID,
		(xdrproc_t) xdr_OIdSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcremoveobjfromcoll_1(RemoveObjFromCollParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCREMOVEOBJFROMCOLL,
		(xdrproc_t) xdr_RemoveObjFromCollParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

OIdRes *
rpcgetnewoid_1(NewOIdParams *argp, CLIENT *clnt)
{
	static OIdRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETNEWOID,
		(xdrproc_t) xdr_NewOIdParams, (caddr_t) argp,
		(xdrproc_t) xdr_OIdRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

ObjectTypeRes *
rpcgetobjecttype_1(OIdSpecParams *argp, CLIENT *clnt)
{
	static ObjectTypeRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETOBJECTTYPE,
		(xdrproc_t) xdr_OIdSpecParams, (caddr_t) argp,
		(xdrproc_t) xdr_ObjectTypeRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetTypeStructureRes *
rpcgettypestructure_1(GetTypeStructureParams *argp, CLIENT *clnt)
{
	static GetTypeStructureRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETTYPESTRUCTURE,
		(xdrproc_t) xdr_GetTypeStructureParams, (caddr_t) argp,
		(xdrproc_t) xdr_GetTypeStructureRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetElementRes *
rpcgetnextelement_1(u_long *argp, CLIENT *clnt)
{
	static GetElementRes clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETNEXTELEMENT,
		(xdrproc_t) xdr_u_long, (caddr_t) argp,
		(xdrproc_t) xdr_GetElementRes, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

int *
rpcgetserverendian_1(int *argp, CLIENT *clnt)
{
	static int clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETSERVERENDIAN,
		(xdrproc_t) xdr_int, (caddr_t) argp,
		(xdrproc_t) xdr_int, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcsetservertransfer_1(SetServerTransferParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCSETSERVERTRANSFER,
		(xdrproc_t) xdr_SetServerTransferParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

GetExtendedErrorInfo *
rpcgeterrorinfo_1(void *argp, CLIENT *clnt)
{
	static GetExtendedErrorInfo clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCGETERRORINFO,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_GetExtendedErrorInfo, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}

u_short *
rpcsetserverstorage_1(SetServerTransferParams *argp, CLIENT *clnt)
{
	static u_short clnt_res;
	enum clnt_stat stat;


	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if ( (stat = clnt_call (clnt, RPCSETSERVERSTORAGE,
		(xdrproc_t) xdr_SetServerTransferParams, (caddr_t) argp,
		(xdrproc_t) xdr_u_short, (caddr_t) &clnt_res,
		TIMEOUT) ) != RPC_SUCCESS ) {
		clnt_perrno( stat );
		return (NULL);
		}
	if (*((u_short*)&clnt_res) == 42)
		{
		GetExtendedErrorInfo* result = NULL;
		int dummy;
		int counter = 0;
		while (!(result = rpcgeterrorinfo_1(&dummy, clnt)) && (counter < RMInit::rpcMaxRetry))
			{
			counter++;
			}
		r_Error* t = NULL, e;
		if (counter == RMInit::rpcMaxRetry)
			t = new r_Error(RPCCOMMUNICATIONFAILURE);
		else
			t = r_Error::getAnyError(result->errorText);
		e=*t;
		delete t;
		throw e;
	}
	return (&clnt_res);
}
