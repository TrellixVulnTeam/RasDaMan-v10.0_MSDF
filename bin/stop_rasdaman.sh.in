#!/bin/bash
#
# This file is part of rasdaman community.
#
# Rasdaman community is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Rasdaman community is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
#
# Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015 Peter Baumann /
# rasdaman GmbH.
#
# For more information please see <http://www.rasdaman.org>
# or contact Peter Baumann via <baumann@rasdaman.com>.      
#
#
# stop_rasdaman.sh - shut down rasdaman server complex
#
# SYNTAX
#       stop_rasdaman.sh
#
# DESCRIPTION
#    This script terminates rasdaman.
#    First, all server processes are terminated. Then, the server
#    manager (rasmgr) is shut down.
#    To log in to the server, the external variable $RASLOGIN is expected to hold
#    an ID string (see rasdaman manual). If not found, a desperate last attempt is
#    made to login as rasadmin/rasadmin. If this fails, no servers are stopped at all.
#
# BE CAREFUL
#    By terminating rasdaman, all open transactions are aborted,
#    and their contents will be irretrievably lost!
#
# PRECONDITIONS
#    - need to have a rasdaman admin login either from $RASLOGIN or as rasadmin/rasadmin
#    - no open transactions or databases, they will be killed and transactions aborted
#

# --- CONSTANTS -----------------------------------------------------

PROG=$(basename $0)

RC_OK=0       # everything went fine
RC_ERROR=1    # something went wrong

RASMGR_PORT=7001

# binaries
rasmgr_bin="@bindir@rasmgr"
rasserver_bin="@bindir@rasserver"
rascontrol_bin="@bindir@rascontrol"

petascope_props="@sysconfdir@petascope.properties"
secore_props="@sysconfdir@secore.properties"

# base DBMS used by petascope
PETASCOPEDB=@petascopedb@

# rasadmin/rasadmin
DEFAULT_RASCONTROL_LOGIN=rasadmin:d293a15562d3e70b6fdc5ee452eaed40
[ -z "$RASLOGIN" ] && export RASLOGIN=$DEFAULT_RASCONTROL_LOGIN

log()  { echo "$PROG: $@"; }
logn() { echo -n "$PROG: $@"; }
error(){ echo "$PROG: $@" >&2; exit $RC_ERROR; }
check(){ [ $? ] && echo "ok." || echo "failed."; }

sleep --help | grep -q GNU && GNU_SLEEP=true
get_sleep_value() { [ $GNU_SLEEP ] && echo "$1" || echo "$2"; }

# give process matching time to disappear
# $1 - process path to match in pgrep
# $2 - timeout in seconds
# $3 - [optional] grep the output of pgrep
wait_for_process_to_shutdown()
{
    local proc_path="$1"
    local proc_name=$(basename "$1")
    local timeout="$2"
    local timeout_tenths=$(($timeout * 10))

    local max_count=$(get_sleep_value $timeout_tenths $timeout)
    local sleep_sec=$(get_sleep_value 0.1 1)
    local count=0
    while [ $count -lt $max_count ]; do
        if [ -n "$3" ]; then
          pgrep -f "$proc_path" -a | grep -q "$3"
        else
          pgrep -f "$proc_path" -a > /dev/null 2>&1
        fi
        [ $? -ne 0 ] && break # no process found, no need to wait more
        count=$(($count+1))
        sleep $sleep_sec      # otherwise, wait 0.1 (or 1) seconds and try again
    done
    if [ $count -eq $max_count ]; then
        echo
        log "timeout of 3 seconds on waiting for $proc_name to shutdown reached;"
        log "please manually check and kill any still running $proc_name processes:"
        log " 1. list the running $proc_name processes: pgrep -f $proc_path"
        log " 2. kill each process with: kill <pid> (or kill -9 <pid> if kill fails)"
    fi
}

# Read the property of a value by input key from input properties file
get_property_value() {
    # $1 is path to input properties file (e.g: /opt/rasdaman/etc/petascope.properties).
    # $2 is the key of a property in this file which needs to get the value of this key.
    local -r properties_file="$1"
    local -r key="$2"
    # only grep key=value line not commented line (e.g: #key=value)
    grep "^$key=" "$properties_file" | sed -e 's/.*=//' -e 's/^[ \t]*//'
}

# Return non-zero if port is available
# $1: the port to check
check_port_available()
{
    local port="$1"
    if type fuser > /dev/null 2>&1; then
        fuser -s -n tcp "$port" > /dev/null 2>&1
    elif type lsof > /dev/null 2>&1; then
        lsof -i ":$port" > /dev/null 2>&1
    elif type netstat > /dev/null 2>&1; then
        netstat -lntu | grep "LISTEN" | awk '{ print $4 }' | grep -q ":$port\$"
    elif type ss > /dev/null 2>&1; then
        ss -lntu | grep "LISTEN" | awk '{ print $5 }' | grep -q ":$port\$"
    else
        return 1 # assume it's available
    fi
}

# --- kill embedded petascope and secore if they are running ---------

# Stop embedded tomcat from values in properties file
# $1: the path to properties file (e.g: /opt/rasdaman/etc/petascope.properties).
# $2: the web application name (e.g: petascope, secore).
stop_embedded() {
    local -r props_path="$1"
    local -r app_name="$2"
    local -r war_file_name="$3"

    if [ -f "$props_path" ]; then
        # check if java-server is embedded/external
        java_server=$(get_property_value "$props_path" "java_server")
        # check if java-server is embedded
        if [ "$java_server" == "embedded" ]; then
            # Check if the port for this application is running and kill this process
            # Get the embedded port for server
            server_port=$(get_property_value "$props_path" "server.port")
            check_port_available "$server_port"
            if [ $? -eq 0 ]; then
                # kill process on this port
                local pid=$(pgrep -f "$war_path/$war_file_name" 2> /dev/null)
                kill -9 $pid
                log "embedded $app_name terminated on port $server_port."
            fi
        fi
    else
        log "Warning - cannot stop embedded $app_name, $props_path not found."
    fi
}


# --- ACTION ------------------------------------------------------

stop_rasmgr_rasservers=false
stop_embedded_petascope=false
stop_embedded_secore=false
stop_all_services=true

# Iterate all input arguments (--service petascope ...)
for ((i=1; i <= $#; i++)); do
    next=$((i+1))

    param="${!i}"
    next_param="${!next}"

    if [ "$param" == "--service" ]; then
        stop_all_services=false
        if [ "$next_param" == "core" ]; then
            stop_rasmgr_rasservers=true
        elif [ "$next_param" == "petascope" ]; then
            stop_embedded_petascope=true
        elif [ "$next_param" == "secore" ]; then
            stop_embedded_secore=true
        fi

        i=$((i+1))
    fi
done

# No options --service specified, stop all services
if [ "$stop_all_services" == true ]; then
    stop_rasmgr_rasservers=true
    stop_embedded_petascope=true
    stop_embedded_secore=true
fi

# Check if it should stop embedded tomcat, secore
if [ "$stop_embedded_secore" == true ]; then
    stop_embedded "$secore_props" "secore" "def.war"
fi

if [ "$stop_embedded_petascope" == true ]; then
    stop_embedded "$petascope_props" "petascope" "rasdaman.war"
fi

if [ "$stop_rasmgr_rasservers" == true ]; then

    # --- stop rasdaman servers ---------------------------------------

    # check if rasmgr is already running first of all
    pgrep -f "$rasmgr_bin --port $RASMGR_PORT" > /dev/null 2>&1 || \
      { log "rasdaman is already down, nothing to do."; exit $RC_OK; }

    log "terminating rasdaman server complex... "

    logn "  terminating rasserver processes... "
    "$rascontrol_bin" --port $RASMGR_PORT -e -q -x down srv -all -kill
    check
    wait_for_process_to_shutdown "$rasserver_bin" 10 "port $RASMGR_PORT"

    # --- stop rasmgr -------------------------------------------------

    # finally shut down the server manager
    logn "  "
    "$rascontrol_bin" --port $RASMGR_PORT -e -q -x down host -all
    wait_for_process_to_shutdown "$rasmgr_bin" 3 "port $RASMGR_PORT"

fi

log "done."

exit $RC_OK

# --- END ACTION ----------------------------------------------------
