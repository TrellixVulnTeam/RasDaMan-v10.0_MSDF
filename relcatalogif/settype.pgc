// This is -*- C++ -*-

/*
* This file is part of rasdaman community.
*
* Rasdaman community is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Rasdaman community is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with rasdaman community.  If not, see <http://www.gnu.org/licenses/>.
*
* Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009 Peter Baumann /
rasdaman GmbH.
*
* For more information please see <http://www.rasdaman.org>
* or contact Peter Baumann via <baumann@rasdaman.com>.
*/
/*************************************************************
 *
 *
 * PURPOSE:
 *   Code with embedded SQL for PostgreSQL DBMS
 *
 *
 * COMMENTS:
 *   uses embedded SQL
 *
 ************************************************************/

#include "config.h"
#include "debug-srv.hh"

// general embedded SQL related definitions
EXEC SQL include "../reladminif/sqlglobals.h";

#include "settype.hh"
#include "mddtype.hh"
#include "reladminif/sqlerror.hh"
#include "reladminif/externs.h"
#include "raslib/rmdebug.hh"
#include "reladminif/objectbroker.hh"

void
SetType::insertInDb() throw (r_Error)
{
    RMDBGENTER(5, RMDebug::module_catalogif, "SetType", "insertInDb() " << myOId << " " << getTypeName());
    ENTER("SetType::insertInDb()")

    EXEC SQL BEGIN DECLARE SECTION;
        long long  mddtypeid;
        char    settypename[VARCHAR_MAXLEN];
        long long    settypeid;
        long long    nullvalueoid;
    EXEC SQL END DECLARE SECTION;

    (void) strncpy( settypename, (char*) getTypeName(), (size_t) sizeof(settypename) );
    settypeid = myOId.getCounter();
    mddtypeid = getMDDType()->getOId();

    TALK( "EXEC SQL INSERT INTO RAS_SETTYPES ( SetTypeId, SetTypeName, MDDTypeOId) VALUES( " << settypeid << ", " << settypename << ", " << mddtypeid << " )" );
    EXEC SQL INSERT INTO RAS_SETTYPES ( SetTypeId, SetTypeName, MDDTypeOId)
       VALUES   ( :settypeid, :settypename, :mddtypeid);
    if (SQLCODE != SQLOK)
    {
        check("SetType::insertInDb()");
        LEAVE("SetType::insertInDb() error: " << SQLCODE );
        generateException();
    }

    if (nullValues != NULL)
    {
        nullValues->setPersistent(true);
        nullvalueoid = nullValues->getOId().getCounter();

        TALK("EXEC SQL INSERT INTO RAS_NULLVALUES ( SetTypeOId, NullValueOId) VALUES	( " << settypeid << ", " << nullvalueoid << " )");
        EXEC SQL INSERT INTO RAS_NULLVALUES ( SetTypeOId, NullValueOId)
          VALUES    ( :settypeid, :nullvalueoid );
        if (SQLCODE != SQLOK)
        {
            check("SetType::insertInDb()");
            LEAVE("SetType::insertInDb() error: " << SQLCODE );
            generateException();
        }
    }

    DBObject::insertInDb();

    LEAVE("SetType::insertInDb()");
    RMDBGEXIT(5, RMDebug::module_catalogif, "SetType", "insertInDb() " << myOId);
}

void
SetType::deleteFromDb() throw (r_Error)
{
    RMDBGENTER(5, RMDebug::module_catalogif, "SetType", "deleteFromDb() " << myOId << " " << getTypeName());
    EXEC SQL BEGIN DECLARE SECTION;
        long    settypeid3;
    EXEC SQL END DECLARE SECTION;

    settypeid3 = myOId.getCounter();

    TALK( "EXEC SQL DELETE FROM RAS_SETTYPES WHERE RAS_SETTYPES.SetTypeId = " << settypeid3 );
    EXEC SQL DELETE FROM RAS_SETTYPES WHERE RAS_SETTYPES.SetTypeId = :settypeid3;
    if (SQLCODE != SQLOK)
    {
        check("SetType::deleteFromDb()");
        LEAVE("SetType::deleteFromDb() error: " << SQLCODE );
        generateException();
    }

    TALK("EXEC SQL DELETE FROM RAS_NULLVALUES WHERE SetTypeOId = " << settypeid3);
    EXEC SQL DELETE FROM RAS_NULLVALUES
    WHERE SetTypeOId = :settypeid3;
    if (SQLCODE != SQLOK && SQLCODE != SQLNODATAFOUND)
    {
        check("SetType::deleteFromDb()");
        LEAVE("SetType::deleteFromDb() error: " << SQLCODE );
        generateException();
    }

    if (nullValues != NULL)
    {
        nullValues->setPersistent(false);
        nullValues->setCached(false);
    }

    DBObject::deleteFromDb();
    RMDBGEXIT(5, RMDebug::module_catalogif, "SetType", "deleteFromDb() " << myOId);
}

void
SetType::readFromDb() throw (r_Error)
{
    RMDBGENTER(5, RMDebug::module_catalogif, "SetType", "readFromDb() " << myOId);
    ENTER("SetType::readFromDb()");
#ifdef RMANBENCHMARK
    DBObject::readTimer.resume();
#endif
    EXEC SQL BEGIN DECLARE SECTION;
        long long  mddtypeid1;
        char    settypename1[VARCHAR_MAXLEN];
        long long    settypeid1;
        long long    nullvalueoid2;
        int   nullValuesTableCheck;
    EXEC SQL END DECLARE SECTION;

    settypeid1 = myOId.getCounter();
    mddtypeid1 = 0;

    TALK( "EXEC SQL SELECT SetTypeName, MDDTypeOId INTO :settypename1, :mddtypeid1 FROM RAS_SETTYPES WHERE SetTypeId = " << settypeid1 );
    EXEC SQL SELECT SetTypeName, MDDTypeOId
       INTO :settypename1, :mddtypeid1
       FROM RAS_SETTYPES
       WHERE SetTypeId = :settypeid1;
    TALK("Sql code: " << SQLCODE);
    if (check("SetType::readFromDb()") != 0)
    {
        if (SQLCODE == SQLNODATAFOUND)  // was: 100 -- PB 2005-feb-13
            throw r_Error(r_Error::r_Error_ObjectUnknown);
        else
            generateException();
    }

    setName(settypename1);
    myType = SETTYPE;
    myMDDType = (MDDType*)ObjectBroker::getObjectByOId(OId(mddtypeid1));

    // test if null values table exists -- DM 2012-jun-12
    EXEC SQL SELECT COUNT(*)
      INTO :nullValuesTableCheck
      FROM pg_tables WHERE tablename = 'ras_nullvalues';

    if (nullValuesTableCheck == 1)
    {
        TALK("EXEC SQL SELECT NullValueOId INTO :nullvalueoid2 FROM RAS_NULLVALUES WHERE SetTypeOId = " << settypeid1);
        EXEC SQL SELECT NullValueOId INTO :nullvalueoid2
          FROM RAS_NULLVALUES
          WHERE SetTypeOId = :settypeid1;
        if (SQLCODE != SQLOK)
        {
            if (SQLCODE != SQLNODATAFOUND)
            {
                LEAVE("SetType::readFromDb()");
                generateException();
            }
            else
            {
                SQLCODE = SQLOK;
                TALK("No null values found.");
            }
        }
        else
        {
            nullValues = (DBMinterval*)ObjectBroker::getObjectByOId(OId(nullvalueoid2, OId::DBMINTERVALOID));
            nullValues->setCached(true);
            TALK("Got null values: " << nullValues->get_string_representation());
        }
    }
    else
    {
        TALK("No support for null values in the database, please upgrade.");
    }

    DBObject::readFromDb();

#ifdef RMANBENCHMARK
    DBObject::readTimer.pause();
#endif

    LEAVE("SetType::readFromDb()");
    RMDBGEXIT(5, RMDebug::module_catalogif, "SetType", "readFromDb() " << myOId);
}

